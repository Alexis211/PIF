################# MATH LIBRARY ###################
#		BECAUSE YOU LOVE MATH AND SO DO I
##################################################

######### BASIC MATH #########
## packages/pif/math/math.pif

let pi : float = 3.1415926536
let tau = 2 * pi

func abs : (x : float) -> float {
	if x >= 0 then return x
			  else return -x
}

func sqrt : (x : float) -> float
	extern sqrt

func cos : (x : float) -> float
	extern cos

func sin : (x : float) -> float {
	return (extern sin : (x : float) -> float) (x)
}

func tan : (x : float) -> float {
	let externTanPtr : (x : float) -> float = extern tan
	return externTanPtr(x)
}

######### COMPLEX NUMBERS #########
## packages/pif/complex/complex.pif
import pif.math

type Complex [
	re, im : float

	method add : (other : Complex) -> Complex {
		return [this.re + other.re, this.im + other.im] : Complex
	}
	method mul : (other : Complex) -> Complex {
		return [this.re * other.re - this.im * other.im, this.im * other.re + this.re * other.im]
	}
	method abs : () -> float {
		return math.sqrt(this.re * this.re + this.im * this.im)
	}
]

let zero = [] : Complex


################# GRAPHICS LIBRARY #######################
#		BECAUSE WE ALL DREW STUFF WHEN WE WERE KIDS
##########################################################

######### SHAPES & STUFF #########
## packages/pif/gfx/shapes.pif

type Size [
	w, h : int
]

type Pos [
	x, y : int
]

######### PRETTY COLORS ##########
## packages/pif/gfx/color.pif

# This is an abstract type
type Color [
	method toRGBA : () -> RGBA
]

type RGBA : Color [
	r, g, b : int
	a : int = 255
	method toRGBA : () -> RGBA {
		return this
	}
]

type HSV : Color [
	h, s, v : float
	a : int = 255
	method toRGBA : () -> RGBA {
		##	Long function that converts HSV to RGB	 - boring
	}
]

let black, white : RGBA = [0, 0, 0], [255, 255, 255]

######### DRAWING SURFACE ##########
## packages/pif/gfx/surface.pif

# This is an abstract type
type Surface [
	size : Size

	method Plot : (pos  : Pos, c : &Color) -> void
]

######### DRAWING WINDOW ##########
## packages/pif/gfx/window.pif

type Window : Surface [
	size = [w = 640, h = 480]
	title : string = "PIF says hello world !"
	visible : bool = false

	constructor {
		# some code that calls the system APIs to create the window

		this.title = this.title
		this.size = this.size
		## THIS SEEMS REDUNDANT, WHAT TO DO ???
		# maybee : set this.title; set this.size; as a shortcut ?

		if this.visible then this.show()
	}
	destructor {
		# some code that cleans up everything
	}

	method show : () -> {
		this.visible = true
		# some code that shows the window
	}
	method hide : () -> {
		this.visible = false
		# some code that hides the window
	}
	set visible {
		## here, the reference to visible is different from this.visible.
		#		this.visible is the old value,
		#		whereas visible is the new value, which must be taken into account by this method
		if visible then this.show() else hide()
	}
	set title {
		# same here
		this.title = title
		# some code that changes the window title.
	}
	set size {
		# code that resizes the window
	}
]

######################### PLOTTING PACKAGE ######################################
#		BECAUSE PLOTTING A PARAMETRIC HEART FOR YOUR GIRLFRIEND IS COOL
#################################################################################

######### PLOTTING COORDINATE SYSTEM ##########
## packages/pif/gfx/plot/window.pif
import pif.gfx

type Point [
	x, y : float
]

type Window [
	(xmin, xmax, ymin, ymax) : float = 0., 1., 0., 1.

	method position : (p : Point, s : gfx.Size) -> gfx.Pos {
		return [
			x = (p.x - this.xmin) / (this.xmax - this.xmin) * s.w
			y = (p.y - this.ymin) / (this.ymax - this.ymin) * s.h
		]
	}

	method inversePosition : (pos : gfx.Pos, s : gfx.Size) -> Point {
		return [
			x = pos.x * (this.xmax - this.xmin) / s.w + this.xmin,
			y = pos.y * (this.ymax - this.ymin) / s.h + this.ymin
		]
	}
]

############################ MANDELBROT & JULIA ####################
#		BECAUSE 'FRACTAL' HAS A NICE SOUND TO IT
####################################################################

######### MANDELBROT ##########
## packages/app/katchup/mandel/mandel.pif
import pif.complex
import pif.gfx
import pif.gfx.plot

let win : &gfx.Window

let iter = 100

func mandel : (pos : complex.Complex) -> int {
	let z = complex.zero
	for i from 0 to iter {
		if z.abs() >= 2 then return i
		z = z.mul(z).add(pos)
	}
	return 0
}

func draw_mandel : (surface : &gfx.Surface, win : plot.Window) -> {
	for i from 0 to surface.size.w {
		for j from 0 to surface.size.h {
			let pt = win.inversePosition([i, j], surface.size)
			let n = mandel([re = pt.x, im = pt.y])
			surface.Plot(pos, [n, n, n] : &gfx.RGBA)
		}
	}
}

func _main : () -> {
	win.size = [w = 800, h = 600]
	win.title = "Lovely Mandelbrot Fractal"
	win.show()
	
	draw_mandel(win, [xmin = -1.6, xmax = 1.6, ymin = -1.5, ymax = 1.5])
}

######### JULIA ##########
## packages/app/katchup/julia/julia.pif
import pif.complex
import pif.gfx
import pif.gfx.plot

let win : &gfx.Window = [
			size = [800, 600],
			title = "Lovely Julia Fractal",
			visible = true
		]

let iter = 100

func julia : (z0, c : complex.Complex) -> int {
	let z = z0
	for i from 0 to iter {
		if z.abs() >= 2 then return i
		z = z.mul(z).add(c)
	}
	return 0
}

func draw_julia : (surface : &gfx.Surface, win : plot.Window, c complex.Complex) -> {
	for i from 0 to surface.size.w {
		for j from 0 to surface.size.h {
			let pt = win.inversePosition([i, j], surface.size)
			let n = julia([re = pt.x, im = pt.y], c)
			surface.Plot(pos, [n, n, n] : &gfx.RGBA)
		}
	}
}

func _main : () -> {
	# view_win here defined is not a reference, so we won't be able to change it.
	let view_win : plot.Window = [xmin = -1.6, xmax = 1.6, ymin = -1.5, ymax = 1.5]
	draw_julia(win, view_win, [0.3, 0.024])
}
